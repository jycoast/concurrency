# synchronized 关键字

**思考：有了分布式锁，还有必要学习使用synchronized 和 Lock吗？**

## synchronized 简介

synchronized 是 Java 的内置锁机制，用于实现线程同步，防止并发问题。它可作用于方法或代码块，确保同一时刻只有一个线程访问受保护代码。

## 用法一：作用于实例方法

```java
public synchronized void instanceMethod() {
    // 代码
}
```

**效果**：锁定当前实例对象（this）。不同实例可并发执行同一方法，但同一实例的多个 synchronized 实例方法互斥。

**适用**：保护实例变量。

## 用法二：作用于静态方法

```java
public static synchronized void staticMethod() {
    // 代码
}
```

**效果**：锁定类对象（Class）。所有实例共享此锁，静态方法互斥执行。

**适用**：保护静态变量。

## 用法三：作用于类

```java
synchronized (ClassName.class) {
    // 代码
}
```

**效果**：等同静态方法锁，锁定类对象。用于非静态方法中实现类级同步。

**适用**：跨实例同步。

## 用法四：作用于任意对象

```java
private final Object lock = new Object();

public void doSomething() {
    synchronized (lock) {
        // 受保护的代码
        count++;
    }
}
```

效果：锁定指定的对象（lock）。只有持有同一对象锁的线程才能互斥执行该代码块。

适用：细粒度控制、保护特定资源、不想锁整个实例或类时使用。

## synchronized 与 Integer

```java
public class SynchronizedInteger {

    static void test() throws Exception {
        Integer lock1 = 100;           // 缓存对象
        Integer lock2 = 100;           // 同一个对象

        Thread t1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("T1 got lock");
                sleep();
                System.out.println("T1 release");
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("T2 got lock");
            }
        });

        t1.start();
        Thread.sleep(100);
        t2.start();
    }

    static void sleep() {
        try {
            Thread.sleep(3000);
        } catch (Exception ignored) {
        }
    }

    public static void main(String[] args) throws Exception {
        test();
    }
}
```

结果：T2 必须等 T1 睡完 3 秒才能打印，意外串行。

## synchronized 与 String

```java
public class SynchronizedString {

    static void test() throws Exception {
        String lockA = "GLOBAL_LOCK";   // 常量池同一对象
        String lockB = "GLOBAL_LOCK";   // 同一对象

        Thread t1 = new Thread(() -> {
            synchronized (lockA) {
                System.out.println("T1 got lock");
                sleep();
                System.out.println("T1 release");
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lockB) {
                System.out.println("T2 got lock");
            }
        });

        t1.start();
        Thread.sleep(100);
        t2.start();
    }

    static void sleep() {
        try {
            Thread.sleep(3000);
        } catch (Exception ignored) {
        }
    }

    public static void main(String[] args) throws Exception {
        test();
    }
}
```

结果：T2 被阻塞，直到 T1 结束 ，不同类/模块间意外互斥。

## synchronized 使用总结

| 使用场景     | 锁对象      | 适用情况                       |
| ------------ | ----------- | ------------------------------ |
| 同步实例方法 | this        | 保护整个实例方法               |
| 同步代码块   | 自定义对象  | 保护部分代码，灵活性更高       |
| 同步静态方法 | Class 对象  | 保护类级别的静态资源           |
| 同步类对象   | Class 对象  | 在实例方法中保护静态资源       |
| 同步不同实例 | 各自的 this | 实例级独立同步，不干扰其他实例 |

# 管程

## 什么是管程

如果不了解这些现象发生的背后的深层次的原因，很容易导致意外的并发安全问题。要了解这些结果产生的原因，就得了解什么是管程。

前面我们提到过在并发编程领域，有两大核心问题：一个是**互斥**，即同一时刻只允许一个线程访问共享资源；另一个是**同步**，即线程之间如何通信、协作。而这两大问题，都可以通过管程来解决。

[管程-维基百科](https://en.wikipedia.org/wiki/Monitor_(synchronization))，对应的英文是Monitor，很多Java领域的同学都喜欢将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”。

所谓**管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发**。翻译为Java领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。那管程是怎么管的呢？

## MESA模型

在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen模型、Hoare模型和MESA模型。其中，现在广泛应用的是MESA模型，并且Java管程的实现参考的也是MESA模型。所以今天我们重点介绍一下MESA模型。

在并发编程领域，有两大核心问题：一个是**互斥**，即同一时刻只允许一个线程访问共享资源；另一个是**同步**，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。

我们先来看看管程是如何解决**互斥**问题的。

管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。假如我们要实现一个线程安全的阻塞队列，一个最直观的想法就是：将线程不安全的队列封装起来，对外提供线程安全的操作方法，例如入队操作和出队操作。

利用管程，可以快速实现这个直观的想法。在下图中，管程X将共享变量queue这个线程不安全的队列和相关的操作入队操作enq()、出队操作deq()都封装起来了；线程A和线程B如果想访问共享变量queue，只能通过调用管程提供的enq()、deq()方法来实现；enq()、deq()保证互斥性，只允许一个线程进入管程。

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/image-20260201175047944.png" alt="image-20260201175047944" style="zoom:67%;" />

那管程如何解决线程间的**同步**问题呢？

在下面，我展示了一幅MESA管程模型示意图，它详细描述了MESA模型的主要组成部分。

在管程模型里，共享变量和对共享变量的操作是被封装起来的，图中最外层的框就代表封装的意思。框的上面只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程同时试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。这个过程类似就医流程的分诊，只允许一个患者就诊，其他患者都在门口等待。   

管程里还引入了条件变量的概念，而且**每个条件变量都对应有一个等待队列，**如下图，条件变量A和条件变量B分别都有自己的等待队列。

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/image-20260201175114449.png" alt="image-20260201175114449" style="zoom:67%;" />

那**条件变量**和**条件变量等待队列**的作用是什么呢？

假设有个线程 T1 执行阻塞队列的出队操作，执行出队操作，需要注意有个前提条件，就是阻塞队列不能是空的（空队列只能出 Null 值，是不允许的），**阻塞队列不空**这个前提条件对应的就是管程里的条件变量。 如果线程 T1 进入管程后恰好发现阻塞队列是空的，那怎么办呢？等待啊，去哪里等呢？就去条件变量对应的**等待队列**里面等。此时线程 T1 就去“队列不空”这个条件变量的等待队列中等待。这个过程类似于大夫发现你要去验个血，于是给你开了个验血的单子，你呢就去验血的队伍里排队。线程 T1 进入条件变量的等待队列后，是允许其他线程进入管程的。这和你去验血的时候，医生可以给其他患者诊治，道理都是一样的。

再假设之后另外一个线程 T2 执行阻塞队列的入队操作，入队操作执行成功之后，**“阻塞队列不空” **这个条件对于线程 T1 来说已经满足了，此时线程 T2 要通知 T1，告诉它需要的条件已经满足了。当线程 T1 得到通知后，会从**等待队列**里面出来，但是出来之后不是马上执行，而是重新进入到**入口等待队列**里面。这个过程类似你验血完，回来找大夫，需要重新分诊。

条件变量及其等待队列我们讲清楚了，下面再说说 wait()、notify()、notifyAll() 这三个操作。前面提到线程 T1 发现“阻塞队列不空”这个条件不满足，需要进到对应的**等待队列**里等待。这个过程就是通过调用 wait() 来实现的。如果我们用对象 A 代表“阻塞队列不空”这个条件，那么线程 T1 需要调用 A.wait()。同理当“阻塞队列不空”这个条件满足时，线程 T2 需要调用 A.notify() 来通知 A 等待队列中的一个线程，此时这个等待队列里面只有线程 T1。至于 notifyAll() 这个方法，它可以通知等待队列中的所有线程。

下面的代码用管程实现了一个线程安全的阻塞队列。阻塞队列有两个操作分别是入队和出队，这两个方法都是先获取互斥锁（通过 `synchronized` 关键字），类比管程模型中的入口。

- 对于阻塞队列的入队操作，如果阻塞队列已满，就需要等待直到阻塞队列不满，所以这里用了 `wait();`，让线程进入条件变量的等待队列。
- 对于阻塞出队操作，如果阻塞队列为空，就需要等待直到阻塞队列不空，所以就用了 `wait();`，让线程进入条件变量的等待队列。
- 如果入队成功，那么阻塞队列就不空了，就需要通知等待队列中的线程，告诉它们"队列不空"这个条件已经满足，所以调用了 `notify();`。
- 如果出队成功，那就阻塞队列就不满了，就需要通知等待队列中的线程，告诉它们"队列不满"这个条件已经满足，所以调用了 `notify();`。

```java

public class SynchronizedMesa<T> {
    private final Queue<T> queue = new LinkedList<>();
    private final int capacity;

    public SynchronizedMesa(int capacity) {
        this.capacity = capacity;
    }

    // 入队
    public synchronized void enq(T x) throws InterruptedException {
        while (queue.size() == capacity) {
            // 队列满，等待"队列不满"这个条件
            // wait() 会让当前线程进入条件变量的等待队列
            this.wait();
        }
        queue.add(x);
        System.out.println("入队: " + x + "，当前大小: " + queue.size());

        // 入队后，队列一定不空，唤醒等待"队列不空"条件的线程
        // notify() 会通知等待队列中的一个线程
        this.notify();
    }

    // 出队
    public synchronized T deq() throws InterruptedException {
        while (queue.isEmpty()) {
            // 队列空，等待"队列不空"这个条件
            // wait() 会让当前线程进入条件变量的等待队列
            this.wait();
        }
        T item = queue.poll();
        System.out.println("出队: " + item + "，当前大小: " + queue.size());

        // 出队后队列不满，唤醒等待"队列不满"条件的线程
        // notify() 会通知等待队列中的一个线程
        this.notify();
        return item;
    }

    // demo
    public static void main(String[] args) {
        SynchronizedMesa<Integer> mesa = new SynchronizedMesa<>(3);

        // 生产者
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    mesa.enq(i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "Producer").start();

        // 消费者
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    mesa.deq();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "Consumer").start();
    }
}
```

在这段示例代码中，我们使用了 Java 内置的 `synchronized` 和 `wait()`、`notify()` 方法。**`wait()` 方法用于让线程进入条件变量的等待队列；`notify()` 方法用于通知等待队列中的一个线程，告诉它条件已经满足**。

需要注意的是，Java 内置的管程（synchronized）只有一个条件变量，所以"队列不满"和"队列不空"这两个条件实际上共享同一个等待队列。但通过 `while` 循环检查不同的条件，我们可以模拟多个条件变量的效果。当线程被唤醒后，会重新检查条件是否满足，如果不满足就继续等待，这正是 MESA 管程模型的特点。

需要注意的是对于 MESA 管程来说，有一个编程范式，就是需要在一个 while 循环里面调用 wait()。**这个是 MESA 管程特有的**。

```java
while(条件不满足) {
  wait();
}
```

Hasen 模型、Hoare 模型和 MESA 模型的一个核心区别就是当条件满足后，如何通知相关线程。管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行呢？

Hasen 模型里面，要求 notify() 放在代码的最后，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。

Hoare 模型里面，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 多了一次阻塞唤醒操作。

MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，**所以需要以循环方式检验条件变量。**

## notify() 何时可以使用

还有一个需要注意的地方，就是 notify() 和 notifyAll() 的使用，前面章节，我曾经介绍过，**除非经过深思熟虑，否则尽量使用 notifyAll()**。那什么时候可以使用 notify() 呢？需要满足以下三个条件：

1. 所有等待线程拥有相同的等待条件；
2. 所有等待线程被唤醒后，执行相同的操作；
3. 只需要唤醒一个线程。

比如上面阻塞队列的例子中，对于“阻塞队列不满”这个条件变量，其等待线程都是在等待“阻塞队列不满”这个条件，反映在代码里就是下面这 3 行代码。对所有等待线程来说，都是执行这 3 行代码，**重点是 while 里面的等待条件是完全相同的**。

管程是一个解决并发问题的模型，你可以参考医院就医的流程来加深理解。理解这个模型的重点在于理解条件变量及其等待队列的工作原理。

Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。MESA 模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。具体如下图所示。

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/image-20260201175349856.png" alt="image-20260201175349856" style="zoom:67%;" />

Java 内置的管程方案（synchronized）使用简单，synchronized 关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是仅支持一个条件变量；而 Java SDK 并发包实现的管程支持多个条件变量，不过并发包里的锁，需要开发人员自己进行加锁和解锁操作。

并发编程里两大核心问题——互斥和同步，都可以由管程来帮你解决。学好管程，理论上所有的并发问题你都可以解决，并且很多并发工具类底层都是管程实现的，所以学好管程，就是相当于掌握了一把并发编程的万能钥匙。

## MESA 与 synchronized

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/68747470733a2f2f626c6f672d313330343835353534332e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f626c6f672f696d6167652d32303235303432373231303632333233352e706e67" alt="image-20250427210623235" style="zoom: 50%;" />

## MESA 与 Lock

Lock在实现的时候，仍然是按照管程的MESA模型来实现的。

<img src="https://blog-1304855543.cos.ap-guangzhou.myqcloud.com/blog/68747470733a2f2f626c6f672d313330343835353534332e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f626c6f672f696d6167652d32303235303432383137313333383034362e706e67" alt="image-20250428171338046" style="zoom: 50%;" />

# synchronized 与管程

## ObjectMonitor

JVM 在底层通过 **monitorenter** 和 **monitorexit** 指令实现 synchronized 的同步机制。这些指令操作对象的监视器。下面是原理的简化和对应的伪代码解释：

- 当线程进入 synchronized (object) 时：
  1. 执行 monitorenter 指令，尝试获取 object 的监视器。
  2. 如果监视器未被占用，线程成功获取并进入代码块。
  3. 如果监视器已被其他线程持有，当前线程阻塞等待。
- 当线程离开 synchronized 块时：
  1. 执行 monitorexit 指令，释放 object 的监视器。
  2. 其他等待的线程可以竞争获取监视器。

监视器的C++代码：

```c++
class ObjectMonitor {
private:
    volatile intptr_t _header;         // 对象头的 Mark Word
    void* _object;                     // 指向被锁的 Java 对象
    pthread_mutex_t _mutex;            // 互斥锁，用于保护监视器
    pthread_cond_t _cond;              // 条件变量，用于线程等待和唤醒
    Thread* _owner;                    // 当前持有锁的线程
    ObjectWaiter* _waiters;            // 等待队列（等待锁的线程）
    int _recursions;                   // 重入次数（支持锁重入）

public:
    ObjectMonitor() {
        _header = 0;
        _object = nullptr;
        _owner = nullptr;
        _waiters = nullptr;
        _recursions = 0;
        pthread_mutex_init(&_mutex, nullptr);
        pthread_cond_init(&_cond, nullptr);
    }

    ~ObjectMonitor() {
        pthread_mutex_destroy(&_mutex);
        pthread_cond_destroy(&_cond);
    }

    void enter(Thread* self);          // 进入监视器（获取锁）
    void exit(Thread* self);           // 退出监视器（释放锁）
    void wait(Thread* self);           // 等待
    void notify(Thread* self);         // 通知一个等待线程
    void notifyAll(Thread* self);      // 通知所有等待线程
};
```

地址：https://hg.openjdk.org/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/runtime/objectMonitor.hpp

搜索：   _EntryList    = NULL ;

**字段说明**：

- _mutex：互斥锁，确保同一时刻只有一个线程操作监视器。
- _cond：条件变量，用于实现 wait() 和 notify() 的等待/唤醒机制。
- _owner：记录当前持有锁的线程。
- _recursions：支持锁的可重入性（同一个线程可以多次获取锁）。
- _waiters：等待队列，存储因锁竞争而阻塞的线程。

## 监视器池

当 synchronized 锁升级为重量级锁时，JVM 需要一个机制来管理锁的竞争，包括记录持有锁的线程、维护等待队列、处理线程的阻塞和唤醒等。由于锁竞争可能发生在多个对象上，JVM 不可能为每个对象都预先分配一个完整的监视器结构（内存开销太大）。因此，JVM 使用一个 **ObjectMonitor 池** 来动态分配和重用监视器对象，以优化内存使用和性能。

在 HotSpot JVM 中，ObjectMonitor 是一个 C++ 类，定义在 `hotspot/src/share/vm/runtime/objectMonitor.hpp` 和 objectMonitor.cpp 中。JVM 通过一个池（或类似的内存管理机制）来维护这些 ObjectMonitor 实例。

### 监视器池的实现

- 全局池：JVM 维护一个全局的 ObjectMonitor 池，通常是一个链表或类似的数据结构，用于存储空闲的 ObjectMonitor 实例。

  - 在源码中，这由 ObjectSynchronizer 类管理（位于 synchronizer.cpp）。

  - 示例字段（简化）：

    ```C++
    static ObjectMonitor* gFreeMonitorList; // 空闲监视器链表
    static volatile intptr_t gMonitorFreeCount; // 空闲监视器数量
    ```

- **初始化**：

  - JVM 启动时会预分配一定数量的 ObjectMonitor 实例，放入空闲池中。
  - 数量通常由 JVM 参数（如 -XX:MonitorBound）控制，默认值取决于系统资源。

  **动态分配**：

  - 当需要新的 ObjectMonitor 时，JVM 从池中取出一个空闲实例。
  - 如果池为空，则动态分配一个新的实例（通过 new ObjectMonitor()）并初始化。

  **回收**：

  - 当锁释放且不再需要某个 ObjectMonitor 时，它会被清理并放回池中，以便重用。

## 为Java对象分配监视器

地址：https://hg.openjdk.org/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/runtime/objectMonitor.cpp

搜索：

### 检查锁状态

- JVM 检查目标对象（如 MyClass.class）的 Mark Word。
- 如果是轻量级锁且竞争加剧，进入锁膨胀流程。

### 从监视器池中获取监视器

- 调用 ObjectSynchronizer::inflate：

  ```c++
  ObjectMonitor* ObjectSynchronizer::inflate(oop obj) {
      if (gFreeMonitorList != NULL) {
          // 从空闲池中取出一个监视器
          ObjectMonitor* monitor = gFreeMonitorList;
          gFreeMonitorList = monitor->next_free();
          gMonitorFreeCount--;
          monitor->recycle(); // 重置状态
          return monitor;
      } else {
          // 池为空，分配新实例
          return new ObjectMonitor();
      }
  }
  ```

- 参数 obj 是被锁的 Java 对象（这里是 MyClass.class）。

> inflate 这个单词是膨胀的意思

### 初始化监视器

- 将 ObjectMonitor 的 _object 字段设置为 MyClass.class 的指针。
- 清空 _owner、_EntryList 等字段，准备接收线程。

### 将 ObjectMonitor 地址写入 Mark Word

在分配 ObjectMonitor 后，JVM 需要将其地址与 Class 对象关联起来，这一过程通过更新 Mark Word 完成。

Mark Word 与监视器

Mark Word 是一个动态结构，其内容根据锁状态变化：

- **无锁**：存储哈希码或 GC 信息。
- **偏向锁**：存储线程 ID 和偏向标志。
- **轻量级锁**：指向线程栈中的锁记录。
- **重量级锁**：存储指向 ObjectMonitor 的指针。

在 64 位 JVM 中，Mark Word 通常是 64 位，格式如下（简化）：

```text
|-----------------------------------------------|
| 锁状态 | 内容                                      |
|--------|------------------------------------------|
| 无锁   | hash:31 | age:4 | 0 | 01                |
| 偏向锁 | thread:54 | epoch:2 | 1 | 01            |
| 轻量级 | ptr_to_lock_record:62 | 00              |
| 重量级 | ptr_to_monitor:62 | 10                  |
|-----------------------------------------------|
```

- **重量级锁状态**：最后两位是 10，其余位存储 ObjectMonitor 的地址。

**写入Mark Word过程**

1. 锁膨胀：

   - ObjectSynchronizer::inflate 返回 ObjectMonitor 实例后，JVM 更新 Mark Word。

   - 示例代码（简化）：

     ```c++
     void inflate_and_associate(oop obj, ObjectMonitor* monitor) {
         markOop mark = obj->mark(); // 获取当前 Mark Word
         if (mark->is_neutral()) {   // 无锁状态
             markOop new_mark = (markOop)(monitor | WEIGHTED_LOCK_FLAG);
             if (Atomic::cmpxchg_ptr(new_mark, obj->mark_addr(), mark) == mark) {
                 monitor->set_object(obj); // 关联对象
             }
         } else if (mark->has_locker()) { // 轻量级锁
             // 撤销轻量级锁，更新为重量级锁
             markOop new_mark = (markOop)(monitor | WEIGHTED_LOCK_FLAG);
             Atomic::cmpxchg_ptr(new_mark, obj->mark_addr(), mark);
         }
     }
     ```

   - 使用 CAS（cmpxchg_ptr）原子地将 ObjectMonitor 地址写入 Mark Word。

2. 标志位设置：

   - 将 Mark Word 的低两位设置为 10，表示重量级锁。
   - 高位存储 ObjectMonitor 的内存地址。

3. 关联完成：

   - 此时，MyClass.class 的 Mark Word 指向 ObjectMonitor，线程通过该指针访问监视器。

### 监视器的后续管理

- 线程竞争：
  - 第一个线程获取锁，ObjectMonitor 的 _owner 设置为该线程。
  - 其他线程加入 _EntryList，通过 pthread_mutex_t 和 futex 阻塞。
- 锁释放：
  - 线程退出 synchronized 块，调用 monitorexit。
  - JVM 检查 _recursions，若为 0，则释放 ObjectMonitor，唤醒 _EntryList 中的线程。
- 回收：
  - 如果 ObjectMonitor 不再需要，JVM 将其放回空闲池（gFreeMonitorList）。

# 思考题

既然 synchronized 和 Lock 都是基于管程来实现的，那为什么已经有了synchronized ，还需要 Lock ？