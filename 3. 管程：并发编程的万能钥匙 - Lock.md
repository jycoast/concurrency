

# Lock 接口

```java
private final ReentrantLock lock = new ReentrantLock();

public void transfer() {
    lock.lock();
    try {
     // 受保护的代码
    count++;
    } finally {
        lock.unlock();
    }
}
```



## Lock的管程实现

```java
package com.jyc.demo.concurrent.monitor;

import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockMesa<T> {
    final Lock lock = new ReentrantLock();
    // 条件变量：队列不满
    final Condition notFull = lock.newCondition();
    // 条件变量：队列不空
    final Condition notEmpty = lock.newCondition();

    private final Queue<T> queue = new LinkedList<>();
    private final int capacity;

    public LockMesa(int capacity) {
        this.capacity = capacity;
    }

    // 入队
    public void enq(T x) throws InterruptedException {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                // 队列满，等待 notFull
                notFull.await();
            }
            queue.add(x);
            System.out.println("入队: " + x + "，当前大小: " + queue.size());

            // 入队后，队列一定不空，唤醒消费者
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    // 出队
    public T deq() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                // 队列空，等待 notEmpty
                notEmpty.await();
            }
            T item = queue.poll();
            System.out.println("出队: " + item + "，当前大小: " + queue.size());

            // 出队后队列不满，唤醒生产者
            notFull.signal();
            return item;
        } finally {
            lock.unlock();
        }
    }

    // demo
    public static void main(String[] args) {
        LockMesa<Integer> mesa = new LockMesa<>(3);

        // 生产者
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    mesa.enq(i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "Producer").start();

        // 消费者
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                try {
                    mesa.deq();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "Consumer").start();
    }
}
```

# synchronized、Lock 与 MESA模型

| 功能/概念          | `synchronized`                        | `Lock`（如 `ReentrantLock`）                   | MESA 模型                          | 说明                           |
| ------------------ | ------------------------------------- | ---------------------------------------------- | ---------------------------------- | ------------------------------ |
| **互斥锁获取**     | 隐式（进入 `synchronized` 块/方法时） | `lock()`                                       | 进入临界区（enter monitor）        | 控制对共享资源的互斥访问       |
| **互斥锁释放**     | 隐式（方法或代码块执行完自动释放）    | `unlock()`                                     | 离开临界区（exit monitor）         | 防止死锁需手动释放 Lock        |
| **等待条件**       | `wait()`（需在同步块中使用）          | `await()`（需结合 `Condition` 使用）           | `wait`（进入等待队列，释放锁）     | 条件等待机制                   |
| **唤醒线程**       | `notify()` / `notifyAll()`            | `signal()` / `signalAll()`                     | `signal`（从等待队列移到就绪队列） | 通知等待线程资源可能可用       |
| **条件对象**       | 无独立条件对象（隐式绑定 monitor）    | `Condition`（通过 `Lock.newCondition()` 获取） | 等待队列（condition queue）        | 每个条件可对应一个等待队列     |
| **可重入性**       | 支持（可重入监视器锁）                | `ReentrantLock` 支持可重入                     | 支持                               | 同一个线程可以多次获取同一把锁 |
| **中断响应**       | `wait()` 可被中断                     | `await()` 可中断                               | `wait` 可中断                      | 支持对等待线程进行中断控制     |
| **是否必须释放锁** | 自动（离开 `synchronized` 代码块）    | 必须手动释放（使用 try-finally 推荐）          | 手动                               | Lock 更灵活，但更易出错        |